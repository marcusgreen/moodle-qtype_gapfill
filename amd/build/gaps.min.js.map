{"version":3,"file":"gaps.min.js","sources":["../src/gaps.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * JavaScript code for parsing gapfill question text.\n *\n * @module qtype_gapfill/gaps\n * @copyright  2025 Marcus Green\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n/**\n * Update JSON settings with new feedback data\n * @param {GapInfo} gapInfo - Object containing gapId and gapText\n * @param {string} correctFeedback - HTML content for correct feedback\n * @param {string} incorrectFeedback - HTML content for incorrect feedback\n * @returns {string} - Updated JSON string\n */\nconst updateJson = (gapInfo, correctFeedback, incorrectFeedback) => {\n  // Get the current JSON data from the hidden field\n  const settingsdata = document.querySelector(\"[name='itemsettings']\");\n  let parsedSettings = {};\n\n  if (settingsdata && settingsdata.value) {\n    try {\n      const parsedData = JSON.parse(settingsdata.value);\n      // Handle both array and object formats for backward compatibility\n      if (Array.isArray(parsedData)) {\n        // Convert array to object format for consistency\n        parsedSettings = {};\n        parsedData.forEach(item => {\n          if (item.itemid) {\n            parsedSettings[item.itemid] = item;\n          }\n        });\n      } else {\n        parsedSettings = parsedData;\n      }\n    } catch (e) {\n      parsedSettings = {};\n    }\n  }\n\n  let found = false;\n\n  // Get delimiter characters\n  const delimitcharsElement = document.getElementById('id_delimitchars');\n  const delimitchars = delimitcharsElement ? delimitcharsElement.value : '';\n\n  // Check if we already have settings for this gap ID\n  for (const key in parsedSettings) {\n    if (parsedSettings[key].itemid === gapInfo.gapId) {\n      parsedSettings[key].correctfeedback = correctFeedback;\n      parsedSettings[key].incorrectfeedback = incorrectFeedback;\n      found = true;\n      break;\n    }\n  }\n\n  // If not found, add new settings\n  if (!found) {\n    const questionId = document.querySelector(\"input[name='id']\");\n    const itemsettings = {\n      itemid: gapInfo.gapId,\n      questionid: questionId ? questionId.value : \"\",\n      correctfeedback: correctFeedback,\n      incorrectfeedback: incorrectFeedback,\n      gaptext: stripdelim(gapInfo.gapText, delimitchars)\n    };\n\n    // Add to parsedSettings object with a unique key\n    // Use the itemid as the key to ensure uniqueness\n    parsedSettings[gapInfo.gapId] = itemsettings;\n  }\n\n  // Convert to array format for consistency\n  const settingsArray = Object.values(parsedSettings);\n  return JSON.stringify(settingsArray);\n};\n\n\n/**\n * Strip delimiter characters from gap text\n * @param {string} gapText - The gap text with delimiters\n * @param {string} delimitchars - The delimiter characters (e.g., '[]')\n * @returns {string} - Gap text without delimiters\n */\nconst stripdelim = (gapText, delimitchars) => {\n  if (!gapText || !delimitchars || delimitchars.length < 2) {\n    return gapText;\n  }\n\n  const leftDelim = delimitchars.charAt(0);\n  const rightDelim = delimitchars.charAt(1);\n  let gaptextNodelim = gapText;\n\n  // Remove left delimiter if present\n  if (gapText.charAt(0) === leftDelim) {\n    gaptextNodelim = gapText.substring(1);\n  }\n\n  // Remove right delimiter if present\n  if (gaptextNodelim.charAt(gaptextNodelim.length - 1) === rightDelim) {\n    gaptextNodelim = gaptextNodelim.substring(0, gaptextNodelim.length - 1);\n  }\n\n  return gaptextNodelim;\n};\n\n/**\n * Escape special regex characters in a string\n * @param {string} str - String to escape\n * @returns {string} - Escaped string\n */\nconst escapeRegex = (str) => {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\n\n/**\n * Get the value from an input element by its ID\n * @param {string} id - Element ID\n * @returns {string|null} - Element value or null if not found\n */\nconst getElementValue = (id) => {\n  const element = document.getElementById(id);\n  return element ? element.value : null;\n};\n\n/**\n * Read existing itemsettings from the hidden field\n * @param {Object} gapInfo - Object containing gapId and gapText\n * @returns {{correctFeedback: string, incorrectFeedback: string}|null} Feedback object, or null on error/not found.\n */\nconst getItemSettings = (gapInfo) => {\n    const itemSettingsField = document.querySelector(\"[name='itemsettings']\");\n    let existingSettings = {};\n    if (itemSettingsField && itemSettingsField.value) {\n        try {\n            const parsedData = JSON.parse(itemSettingsField.value);\n            // Handle both array and object formats for backward compatibility\n            if (Array.isArray(parsedData)) {\n                // Convert array to object format for consistency\n                existingSettings = {};\n                parsedData.forEach(item => {\n                    if (item.itemid) {\n                        existingSettings[item.itemid] = item;\n                    }\n                });\n            } else {\n                existingSettings = parsedData;\n            }\n        } catch (e) {\n            // If parsing fails, start with empty object\n            existingSettings = {};\n        }\n    }\n\n    const searchId = gapInfo && gapInfo.gapId;\n    if (!searchId) {\n        return null;\n    }\n\n    const innerObjects = Object.values(existingSettings);\n\n    const foundObject = innerObjects.find(\n        item => item.itemid === searchId\n    );\n\n    if (foundObject) {\n        return {\n            correctFeedback: foundObject.correctfeedback,\n            incorrectFeedback: foundObject.incorrectfeedback\n        };\n    } else {\n        return null;\n    }\n};\n\n/**\n * Parse question text and wrap gaps in spans with unique IDs\n *\n * The function generates IDs based on two factors:\n * 1. Position in text (first number): id1, id2, id3, etc.\n * 2. Occurrence count of each unique gap content (second number): _0, _1, _2, etc.\n *\n * Example:\n * Input:  \"The big [cat] met the small [cat]\"\n * Output: \"The big <span id=\\\"id1_0\\\">[cat]</span> met the small <span id=\\\"id2_1\\\">[cat]</span>\"\n *\n * Explanation:\n * - First [cat]: id1_0 (position 1, first occurrence of \"cat\")\n * - Second [cat]: id2_1 (position 2, second occurrence of \"cat\")\n *\n * @param {string} questionText - Raw question text containing gaps\n * @returns {string} - Processed HTML string with gaps wrapped in spans\n */\nconst parseQuestionText = (questionText) => {\n  const delimitchars = getElementValue('id_delimitchars');\n\n  if (!delimitchars || delimitchars.length !== 2) {\n    return questionText;\n  }\n\n  const leftDelim = delimitchars.charAt(0);\n  const rightDelim = delimitchars.charAt(1);\n  let processedText = questionText;\n  let gapCounter = 0;\n  const gapContentCounts = new Map();\n\n  // Find all occurrences of text within delimiters\n  const regex = new RegExp(\n    escapeRegex(leftDelim) + '(.*?)' + escapeRegex(rightDelim),\n    'g'\n  );\n\n  processedText = processedText.replace(regex, (match, gapContent) => {\n    gapCounter++;\n\n    // Track occurrence count for this specific gap content\n    const currentCount = gapContentCounts.get(gapContent) || 0;\n    gapContentCounts.set(gapContent, currentCount + 1);\n\n    // Create ID: position_counter (e.g., id1_0, id2_1)\n      const spanId = 'id' + gapCounter + '_' + currentCount;\n      const settings = getItemSettings({ gapId: spanId }) || {};\n      const classes = [];\n      if (settings.correctFeedback?.trim()) {\n        classes.push('hascorrect');\n      }\n      if (settings.incorrectFeedback?.trim()) {\n        classes.push('hasnocorrect');\n      }\n      const classAttr = classes.length ? ' class=\"' + classes.join(' ') + ' item\"' : ' class=\"item\"';\n      return '<span id=\"' + spanId + '\"' + classAttr + '>' + match + '</span>';\n  });\n\n  return processedText;\n};\n\n/**\n * Determines if click was within a gap span and extracts gap information\n *\n * @param {Event} clickEvent - The click event to analyze\n * @returns {Object|null} - Object with gapId, gapText, hascorrect, and hasincorrect, or null if not a gap click\n */\nconst getGap = (clickEvent) => {\n  // Get the target element from the click event\n  let target = clickEvent.target;\n\n  // Check if the target or any of its parents is a gap span\n  let gapSpan = target;\n  while (gapSpan && gapSpan.tagName !== 'SPAN') {\n    gapSpan = gapSpan.parentNode;\n  }\n\n  // If we found a span, check if it has an id attribute starting with 'id'\n  if (gapSpan && gapSpan.id && gapSpan.id.startsWith('id')) {\n    return {\n      gapId: gapSpan.id,\n      gapText: gapSpan.textContent || gapSpan.innerText,\n    };\n  }\n\n  // Not a gap click\n  return null;\n};\n\n/**\n * Update gap classes based on feedback content\n * @param {Object} gapInfo - Object containing gapId\n * @param {string} correctFeedback - HTML content for correct feedback\n * @param {string} incorrectFeedback - HTML content for incorrect feedback\n */\nconst updateGapClasses = (gapInfo, correctFeedback, incorrectFeedback) => {\n  const gapSpan = document.getElementById(gapInfo.gapId);\n  if (!gapSpan) {\n    return;\n  }\n\n  // Remove existing classes\n  gapSpan.classList.remove('hascorrect', 'hasnocorrect');\n\n  // Add classes based on feedback content\n  if (correctFeedback && correctFeedback.trim() !== '') {\n    gapSpan.classList.add('hascorrect');\n  }\n  if (incorrectFeedback && incorrectFeedback.trim() !== '') {\n    gapSpan.classList.add('hasnocorrect');\n  }\n};\n\n/**\n * Update gap classes from existing settings\n * @param {Object} gapInfo - Object containing gapId and gapText\n */\nconst updateGapClassesFromSettings = (gapInfo) => {\n  const settings = getItemSettings(gapInfo);\n  if (settings) {\n    updateGapClasses(gapInfo, settings.correctFeedback, settings.incorrectFeedback);\n  }\n};\n\n/**\n * Initialize gap classes for all gaps in the document\n */\nconst initializeAllGapClasses = () => {\n  // Get all gap spans in the document\n  const gapSpans = document.querySelectorAll('span[id^=\"id\"]');\n\n  if (gapSpans.length === 0) {\n    return;\n  }\n\n  // Get the current itemsettings\n  const itemSettingsField = document.querySelector(\"[name='itemsettings']\");\n  if (!itemSettingsField || !itemSettingsField.value) {\n    return;\n  }\n\n  try {\n    const parsedData = JSON.parse(itemSettingsField.value);\n    let existingSettings = {};\n\n    // Handle both array and object formats\n    if (Array.isArray(parsedData)) {\n      parsedData.forEach(item => {\n        if (item.itemid) {\n          existingSettings[item.itemid] = item;\n        }\n      });\n    } else {\n      existingSettings = parsedData;\n    }\n\n    // Apply classes to each gap\n    gapSpans.forEach(gapSpan => {\n      const gapId = gapSpan.id;\n      const settings = existingSettings[gapId];\n\n      if (settings) {\n        // Remove existing classes\n        gapSpan.classList.remove('hascorrect', 'hasincorrect');\n\n        // Add classes based on feedback content\n        if (settings.correctfeedback && settings.correctfeedback.trim() !== '') {\n          gapSpan.classList.add('hascorrect');\n        }\n        if (settings.incorrectfeedback && settings.incorrectfeedback.trim() !== '') {\n          gapSpan.classList.add('hasincorrect');\n        }\n      }\n    });\n  } catch (e) {\n    // Debug logging for initialization failures\n    // console.debug('Failed to initialize gap classes:', e);\n  }\n};\n\nexport {\n  parseQuestionText,\n  getGap,\n  updateJson,\n  getItemSettings,\n  stripdelim,\n  updateGapClasses,\n  updateGapClassesFromSettings,\n  initializeAllGapClasses\n};\n"],"names":["gapInfo","correctFeedback","incorrectFeedback","settingsdata","document","querySelector","parsedSettings","value","parsedData","JSON","parse","Array","isArray","forEach","item","itemid","e","found","delimitcharsElement","getElementById","delimitchars","key","gapId","correctfeedback","incorrectfeedback","questionId","itemsettings","questionid","gaptext","stripdelim","gapText","settingsArray","Object","values","stringify","length","leftDelim","charAt","rightDelim","gaptextNodelim","substring","escapeRegex","str","replace","getItemSettings","itemSettingsField","existingSettings","searchId","foundObject","find","questionText","id","element","getElementValue","processedText","gapCounter","gapContentCounts","Map","regex","RegExp","match","gapContent","currentCount","get","set","spanId","settings","classes","_settings$correctFeed","trim","push","_settings$incorrectFe","join","clickEvent","gapSpan","target","tagName","parentNode","startsWith","textContent","innerText","updateGapClasses","classList","remove","add","gapSpans","querySelectorAll"],"mappings":"4VA6BmB,CAACA,QAASC,gBAAiBC,2BAEtCC,aAAeC,SAASC,cAAc,6BACxCC,eAAiB,MAEjBH,cAAgBA,aAAaI,gBAEvBC,WAAaC,KAAKC,MAAMP,aAAaI,OAEvCI,MAAMC,QAAQJ,aAEhBF,eAAiB,GACjBE,WAAWK,SAAQC,OACbA,KAAKC,SACPT,eAAeQ,KAAKC,QAAUD,UAIlCR,eAAiBE,WAEnB,MAAOQ,GACPV,eAAiB,OAIjBW,OAAQ,QAGNC,oBAAsBd,SAASe,eAAe,mBAC9CC,aAAeF,oBAAsBA,oBAAoBX,MAAQ,OAGlE,MAAMc,OAAOf,kBACZA,eAAee,KAAKN,SAAWf,QAAQsB,MAAO,CAChDhB,eAAee,KAAKE,gBAAkBtB,gBACtCK,eAAee,KAAKG,kBAAoBtB,kBACxCe,OAAQ,YAMPA,MAAO,OACJQ,WAAarB,SAASC,cAAc,oBACpCqB,aAAe,CACnBX,OAAQf,QAAQsB,MAChBK,WAAYF,WAAaA,WAAWlB,MAAQ,GAC5CgB,gBAAiBtB,gBACjBuB,kBAAmBtB,kBACnB0B,QAASC,WAAW7B,QAAQ8B,QAASV,eAKvCd,eAAeN,QAAQsB,OAASI,mBAI5BK,cAAgBC,OAAOC,OAAO3B,uBAC7BG,KAAKyB,UAAUH,sBAUlBF,WAAa,CAACC,QAASV,oBACtBU,UAAYV,cAAgBA,aAAae,OAAS,SAC9CL,cAGHM,UAAYhB,aAAaiB,OAAO,GAChCC,WAAalB,aAAaiB,OAAO,OACnCE,eAAiBT,eAGjBA,QAAQO,OAAO,KAAOD,YACxBG,eAAiBT,QAAQU,UAAU,IAIjCD,eAAeF,OAAOE,eAAeJ,OAAS,KAAOG,aACvDC,eAAiBA,eAAeC,UAAU,EAAGD,eAAeJ,OAAS,IAGhEI,qDAQHE,YAAeC,KACZA,IAAIC,QAAQ,sBAAuB,QAkBtCC,gBAAmB5C,gBACf6C,kBAAoBzC,SAASC,cAAc,6BAC7CyC,iBAAmB,MACnBD,mBAAqBA,kBAAkBtC,gBAE7BC,WAAaC,KAAKC,MAAMmC,kBAAkBtC,OAE5CI,MAAMC,QAAQJ,aAEdsC,iBAAmB,GACnBtC,WAAWK,SAAQC,OACXA,KAAKC,SACL+B,iBAAiBhC,KAAKC,QAAUD,UAIxCgC,iBAAmBtC,WAEzB,MAAOQ,GAEL8B,iBAAmB,SAIrBC,SAAW/C,SAAWA,QAAQsB,UAC/ByB,gBACM,WAKLC,YAFehB,OAAOC,OAAOa,kBAEFG,MAC7BnC,MAAQA,KAAKC,SAAWgC,kBAGxBC,YACO,CACH/C,gBAAiB+C,YAAYzB,gBAC7BrB,kBAAmB8C,YAAYxB,mBAG5B,0EAsBY0B,qBACnB9B,aA1EiB+B,CAAAA,WACjBC,QAAUhD,SAASe,eAAegC,WACjCC,QAAUA,QAAQ7C,MAAQ,MAwEZ8C,CAAgB,uBAEhCjC,cAAwC,IAAxBA,aAAae,cACzBe,mBAGHd,UAAYhB,aAAaiB,OAAO,GAChCC,WAAalB,aAAaiB,OAAO,OACnCiB,cAAgBJ,aAChBK,WAAa,QACXC,iBAAmB,IAAIC,IAGvBC,MAAQ,IAAIC,OAChBlB,YAAYL,WAAa,QAAUK,YAAYH,YAC/C,YAGFgB,cAAgBA,cAAcX,QAAQe,OAAO,CAACE,MAAOC,8DACnDN,mBAGMO,aAAeN,iBAAiBO,IAAIF,aAAe,EACzDL,iBAAiBQ,IAAIH,WAAYC,aAAe,SAGxCG,OAAS,KAAOV,WAAa,IAAMO,aACnCI,SAAWtB,gBAAgB,CAAEtB,MAAO2C,UAAa,GACjDE,QAAU,iCACZD,SAASjE,kDAATmE,sBAA0BC,QAC5BF,QAAQG,KAAK,4CAEXJ,SAAShE,oDAATqE,sBAA4BF,QAC9BF,QAAQG,KAAK,sBAGR,aAAeL,OAAS,KADbE,QAAQhC,OAAS,WAAagC,QAAQK,KAAK,KAAO,SAAW,iBAC9B,IAAMZ,MAAQ,aAG5DN,+BASOmB,iBAKVC,QAHSD,WAAWE,YAIjBD,SAA+B,SAApBA,QAAQE,SACxBF,QAAUA,QAAQG,kBAIhBH,SAAWA,QAAQvB,IAAMuB,QAAQvB,GAAG2B,WAAW,MAC1C,CACLxD,MAAOoD,QAAQvB,GACfrB,QAAS4C,QAAQK,aAAeL,QAAQM,WAKrC,YASHC,iBAAmB,CAACjF,QAASC,gBAAiBC,2BAC5CwE,QAAUtE,SAASe,eAAenB,QAAQsB,OAC3CoD,UAKLA,QAAQQ,UAAUC,OAAO,aAAc,gBAGnClF,iBAA8C,KAA3BA,gBAAgBoE,QACrCK,QAAQQ,UAAUE,IAAI,cAEpBlF,mBAAkD,KAA7BA,kBAAkBmE,QACzCK,QAAQQ,UAAUE,IAAI,mGAQYpF,gBAC9BkE,SAAWtB,gBAAgB5C,SAC7BkE,UACFe,iBAAiBjF,QAASkE,SAASjE,gBAAiBiE,SAAShE,qDAOjC,WAExBmF,SAAWjF,SAASkF,iBAAiB,qBAEnB,IAApBD,SAASlD,oBAKPU,kBAAoBzC,SAASC,cAAc,4BAC5CwC,mBAAsBA,kBAAkBtC,gBAKrCC,WAAaC,KAAKC,MAAMmC,kBAAkBtC,WAC5CuC,iBAAmB,GAGnBnC,MAAMC,QAAQJ,YAChBA,WAAWK,SAAQC,OACbA,KAAKC,SACP+B,iBAAiBhC,KAAKC,QAAUD,SAIpCgC,iBAAmBtC,WAIrB6E,SAASxE,SAAQ6D,gBACTpD,MAAQoD,QAAQvB,GAChBe,SAAWpB,iBAAiBxB,OAE9B4C,WAEFQ,QAAQQ,UAAUC,OAAO,aAAc,gBAGnCjB,SAAS3C,iBAAuD,KAApC2C,SAAS3C,gBAAgB8C,QACvDK,QAAQQ,UAAUE,IAAI,cAEpBlB,SAAS1C,mBAA2D,KAAtC0C,SAAS1C,kBAAkB6C,QAC3DK,QAAQQ,UAAUE,IAAI,oBAI5B,MAAOpE"}