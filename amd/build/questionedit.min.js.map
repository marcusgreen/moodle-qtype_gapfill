{"version":3,"file":"questionedit.min.js","sources":["../src/questionedit.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle. If not, see <http://www.gnu.org/licenses/>.\n/**\n * JavaScript code for the gapfill question type.\n *\n * @copyright  2017 Marcus Green\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n/* globals tinyMCE */\n/* The data is stored in a hidden field */\ndefine([\n    'qtype_gapfill/Item',\n    'core/modal_factory',\n    'core/modal_events'\n], function(Item, ModalFactory, ModalEvents) {\n  return {\n    init: function() {\n      /**\n       * Helper function to set element properties by ID\n       * @param {string} id - Element ID\n       * @param {object} properties - Object containing property-value pairs to set\n       */\n      const setElementProps = (id, properties) => {\n        let element = document.getElementById(id);\n        if (element) {\n          Object.keys(properties).forEach(prop => {\n            element[prop] = properties[prop];\n          });\n        }\n      };\n      /**\n       * Check which editor is active on the page\n       * @return {string|null} Returns 'tinymce', 'atto', or null if neither is active\n       */\n      const getActiveEditor = () => {\n        // Check if TinyMCE is active\n        if (document.querySelector('.tox-tinymce')) {\n          return 'tinymce';\n        }\n        // Check if Atto is active\n        let attoIsLive = document.querySelectorAll('.editor_atto').length;\n        if (attoIsLive > 0) {\n          return 'atto';\n        }\n        return null;\n      };\n      /**\n       * Handle TinyMCE editor specific item settings functionality\n       */\n      const handleTinyItemSettings = () => {\n        // Access TinyMCE through the global tinyMCE object\n        if (typeof tinyMCE === 'undefined') {\n          console.error('TinyMCE global object not available');\n          return;\n        }\n\n        // Find the TinyMCE editor instance for questiontext\n        // Try common TinyMCE editor IDs used in Moodle\n        let possibleIds = ['id_questiontext_editor', 'id_questiontexteditable', 'id_questiontext'];\n        let editor = null;\n        for (let id of possibleIds) {\n          editor = tinyMCE.get(id);\n          if (editor) {\n            break;\n          }\n        }\n        // If still not found, try to find any TinyMCE editor in the questiontext area\n        if (!editor && tinyMCE.editors && tinyMCE.editors.length > 0) {\n          // Look for an editor whose container is within the questiontext area\n          for (let ed of tinyMCE.editors) {\n            let container = ed.getContainer();\n            if (container && container.closest('#fitem_id_questiontext')) {\n              editor = ed;\n              break;\n            }\n          }\n        }\n        if (!editor) {\n          console.error('TinyMCE editor not found. Available editors:', tinyMCE.editors);\n          console.error('Tried IDs:', possibleIds);\n          return;\n        }\n        let canvas = document.getElementById('id_itemsettings_canvas');\n        let isCanvasVisible = canvas.style.display === 'block';\n        if (!isCanvasVisible) {\n          // Switch to canvas mode (disable editing)\n          // Get the content from TinyMCE\n          let editorContent = editor.getContent();\n          // Get the editor container dimensions\n          let editorContainer = editor.getContainer();\n          let settingformheight = window.getComputedStyle(editorContainer).height;\n          let settingformwidth = window.getComputedStyle(editorContainer).width;\n          // Disable TinyMCE editor\n          editor.mode.set('readonly');\n          // Disable all toolbar buttons\n          let toolbarButtons = editorContainer.querySelectorAll('button');\n          toolbarButtons.forEach(button => {\n            button.setAttribute('disabled', 'true');\n          });\n          // Hide the editor container\n          editorContainer.style.display = 'none';\n          // Setup the canvas\n          canvas.style.position = 'relative';\n          canvas.style.display = 'block';\n          canvas.style.background = 'lightgrey';\n          canvas.style.padding = '10px';\n          canvas.style.border = '1px solid #ccc';\n          canvas.style.minHeight = settingformheight;\n          canvas.style.width = settingformwidth;\n          canvas.innerHTML = editorContent;\n          // Insert canvas after the editor container\n          editorContainer.parentNode.insertBefore(canvas, editorContainer.nextSibling);\n          // Update button text\n          document.getElementById('id_itemsettings_button').innerHTML =\n            M.util.get_string('editquestiontext', 'qtype_gapfill');\n          // Wrap content should be last as it sometimes falls over with an error\n          wrapContent(canvas);\n        } else {\n          // Switch back to edit mode (enable editing)\n          // Show the editor container\n          let editorContainer = editor.getContainer();\n          editorContainer.style.display = 'block';\n          // Enable TinyMCE editor\n          editor.mode.set('design');\n          // Enable all toolbar buttons\n          let toolbarButtons = editorContainer.querySelectorAll('button');\n          toolbarButtons.forEach(button => {\n            button.removeAttribute('disabled');\n          });\n          // Hide the canvas\n          canvas.style.display = 'none';\n          // Hide settings popup if it exists\n          let settingsPopup = document.getElementById('id_settings_popup');\n          if (settingsPopup) {\n            settingsPopup.style.display = 'none';\n          }\n          // Update button text\n          document.getElementById('id_itemsettings_button').innerHTML =\n            M.util.get_string('additemsettings', 'qtype_gapfill');\n        }\n      };\n      /**\n       * Handle Atto editor specific item settings functionality\n       */\n      const handleAttoItemSettings = () => {\n        let questionTextEditable = document.getElementById('id_questiontexteditable');\n        if (questionTextEditable.isContentEditable) {\n          questionTextEditable.setAttribute('contenteditable', 'false');\n          // Disable all buttons in fitem_id_questiontext\n          let buttons = document.getElementById('fitem_id_questiontext').querySelectorAll('button');\n          buttons.forEach(button => {\n            button.setAttribute('disabled', 'true');\n          });\n          let settingformheight = window.getComputedStyle(questionTextEditable).height;\n          let settingformwidth = window.getComputedStyle(questionTextEditable).width;\n          questionTextEditable.style.display = 'none';\n          /* Copy the styles from attos editable area so the canvas looks the same (except gray) */\n          let canvas = document.getElementById('id_itemsettings_canvas');\n          let styles = copyStyles(questionTextEditable);\n          Object.assign(canvas.style, styles);\n          let ed = questionTextEditable.closest('.editor_atto_content_wrap');\n          ed.appendChild(canvas);\n          canvas.style.position = 'relative';\n          canvas.style.display = 'block';\n          canvas.style.background = 'lightgrey';\n          /* Copy the real html to the feedback editing html */\n          canvas.innerHTML = questionTextEditable.innerHTML;\n          canvas.style.height = settingformheight;\n          canvas.style.width = settingformwidth;\n          canvas.style.height = '100%';\n          canvas.style.width = '100%';\n          document.getElementById('id_itemsettings_button').innerHTML =\n            M.util.get_string('editquestiontext', 'qtype_gapfill');\n          /* Setting the height by hand gets around a quirk of MSIE */\n          canvas.style.height = window.getComputedStyle(questionTextEditable).height;\n          /* Disable the buttons on questiontext but not on the feedback form */\n          /* wrapContent should be the last on this block as it sometimes falls over with an error */\n          wrapContent(canvas);\n        } else {\n          questionTextEditable.style.display = 'block';\n          questionTextEditable.style.backgroundColor = 'white';\n          questionTextEditable.setAttribute('contenteditable', 'true');\n          document.getElementById('id_itemsettings_canvas').style.display = 'none';\n          // Enable all buttons in fitem_id_questiontext\n          let buttons = document.getElementById('fitem_id_questiontext').querySelectorAll('button');\n          buttons.forEach(button => {\n            button.removeAttribute('disabled');\n          });\n          document.getElementById('id_settings_popup').style.display = 'none';\n          document.getElementById('id_itemsettings_button').innerHTML =\n            M.util.get_string('additemsettings', 'qtype_gapfill');\n          // Enable all elements with class starting with atto_\n          let attoElements = document.querySelectorAll('[class^=\"atto_\"]');\n          attoElements.forEach(element => {\n            element.removeAttribute('disabled');\n          });\n        }\n      };\n      document.getElementById('id_answerdisplay').addEventListener('change', function() {\n        let selected = this.value;\n        if (selected == 'gapfill') {\n          setElementProps('id_fixedgapsize', { disabled: false });\n          setElementProps('id_optionsaftertext', { disabled: true, checked: false });\n          setElementProps('id_singleuse', { disabled: true, checked: false });\n          setElementProps('id_disableregex', { disabled: false });\n        }\n        if (selected == 'dragdrop') {\n          setElementProps('id_optionsaftertext', { disabled: false });\n          setElementProps('id_singleuse', { disabled: false });\n          setElementProps('id_fixedgapsize', { disabled: false });\n          setElementProps('id_disableregex', { disabled: false });\n        }\n        if (selected == 'dropdown') {\n          setElementProps('id_fixedgapsize', { disabled: true, checked: false });\n          setElementProps('id_optionsaftertext', { disabled: true, checked: false });\n          setElementProps('id_singleuse', { disabled: true, checked: false });\n          setElementProps('id_disableregex', { disabled: true, checked: false });\n        }\n      });\n      /* A click on the itemsettings button */\n      document.getElementById('id_itemsettings_button').addEventListener('click', function() {\n        let activeEditor = getActiveEditor();\n        /* Show error if no supported editor is active. It might be because the page has not finished loading\n         * or because plain text elements are being used or (perhaps less likely as time goes on)\n         * the HTMLarea editor is being used. It might be possible to work with those other editors\n         * but limiting to supported editors keeps things straightforward and maintainable.\n         */\n        if (!activeEditor) {\n          let errorElement = document.getElementById('id_error_itemsettings_button');\n          errorElement.style.display = 'inline';\n          errorElement.style.color = 'red';\n          errorElement.innerHTML = M.util.get_string(\n            'itemsettingserror',\n            'qtype_gapfill'\n          );\n          return;\n        }\n        // Disable editor-specific buttons based on active editor\n        if (activeEditor === 'atto') {\n          let htmlButtons = document.querySelectorAll('#questiontext .atto_html_button');\n          htmlButtons.forEach(button => {\n            button.setAttribute('disabled', 'true');\n          });\n          // Invoke the Atto-specific function\n          handleAttoItemSettings();\n        } else if (activeEditor === 'tinymce') {\n            handleTinyItemSettings();\n        }\n      });\n      /* A click on the text */\n      document.getElementById('id_itemsettings_canvas').addEventListener('click', function(e) {\n        /*\n         * Questiontext needs to be editable and the target must start\n         * with id followed by one or more digits and an underscore\n         *\n         * For TinyMCE, id_questiontexteditable doesn't exist, so we check if it exists first.\n         * If it doesn't exist (TinyMCE), we proceed. If it does exist (Atto), we check if it's NOT editable.\n         * */\n        let questionTextEditable = document.getElementById('id_questiontexteditable');\n        let canProceed = !questionTextEditable || !questionTextEditable.isContentEditable;\n\n        if (\n          canProceed &&\n          e.target.id.match(/^id[0-9]+_/)\n        ) {\n          let delimitchars = document.getElementById('id_delimitchars').value;\n          let item = new Item(e.target.innerHTML, delimitchars);\n          // Var item = new Item(e.target.innerHTML, delimitchars);\n          let itemsettings = item.getItemSettings(e.target);\n          if (itemsettings === null || itemsettings.length === 0) {\n            document.getElementById('id_correct').innerHTML = '';\n            document.getElementById('id_incorrect').innerHTML = '';\n          } else {\n            document.getElementById('id_correct').innerHTML = itemsettings.correctfeedback;\n            document.getElementById('id_incorrect').innerHTML = itemsettings.incorrectfeedback;\n          }\n          // Set label texts\n          let correctLabels = document.querySelectorAll(\"label[for*='id_correct']\");\n          correctLabels.forEach(label => {\n            label.textContent = M.util.get_string('correct', 'qtype_gapfill');\n          });\n          let incorrectLabels = document.querySelectorAll(\"label[for*='id_incorrect']\");\n          incorrectLabels.forEach(label => {\n            label.textContent = M.util.get_string('incorrect', 'qtype_gapfill');\n          });\n          // Disable specific atto buttons\n          let imageButtons = document.querySelectorAll('#id_itemsettings_popup .atto_image_button');\n          imageButtons.forEach(button => {\n            button.setAttribute('disabled', 'true');\n          });\n          let mediaButtons = document.querySelectorAll('#id_itemsettings_popup .atto_media_button');\n          mediaButtons.forEach(button => {\n            button.setAttribute('disabled', 'true');\n          });\n          let manageFilesButtons = document.querySelectorAll('#id_itemsettings_popup .atto_managefiles_button');\n          manageFilesButtons.forEach(button => {\n            button.setAttribute('disabled', 'true');\n          });\n          let title = M.util.get_string('additemsettings', 'qtype_gapfill');\n          /* The html jquery call will turn any encoded entities such as &gt; to html, i.e. > */\n          let tempDiv = document.createElement('div');\n          tempDiv.innerHTML = item.stripdelim();\n          title += ': ' + tempDiv.textContent;\n          // Use Moodle ModalFactory instead of jQuery UI\n          openItemSettingsDialog(item, e, title);\n        }\n      });\n      const openItemSettingsDialog = (item, e, title) => {\n        // Get the content from the popup element\n        let popupContent = document.getElementById('id_itemsettings_popup');\n        ModalFactory.create({\n          type: ModalFactory.types.SAVE_CANCEL,\n          title: title,\n          body: popupContent.innerHTML,\n          large: true\n        }).then(function(modal) {\n          // Show the modal\n          modal.show();\n          // Make the modal wider by adjusting the max-width\n          const modalRoot = modal.getRoot()[0];\n          const modalDialog = modalRoot.querySelector('.modal-dialog');\n          if (modalDialog) {\n            modalDialog.style.maxWidth = '90%';\n          }\n          // Get the modal root element to manipulate content\n          // After the modal is shown, we need to copy content from modal back to original elements\n          modal.getRoot().on(ModalEvents.shown, function() {\n            // Find the editable elements in the modal\n            let modalCorrect = modalRoot.querySelector('#id_correcteditable');\n            let modalIncorrect = modalRoot.querySelector('#id_incorrecteditable');\n            // Get the original elements\n            let originalCorrect = document.getElementById('id_correcteditable');\n            let originalIncorrect = document.getElementById('id_incorrecteditable');\n            // Copy content from original to modal\n            if (modalCorrect && originalCorrect) {\n              modalCorrect.innerHTML = originalCorrect.innerHTML;\n            }\n            if (modalIncorrect && originalIncorrect) {\n              modalIncorrect.innerHTML = originalIncorrect.innerHTML;\n            }\n          });\n          // Handle the save event\n          modal.getRoot().on(ModalEvents.save, function() {\n            // Copy content from modal back to original elements before updating JSON\n            let modalCorrect = modalRoot.querySelector('#id_correcteditable');\n            let modalIncorrect = modalRoot.querySelector('#id_incorrecteditable');\n            let originalCorrect = document.getElementById('id_correcteditable');\n            let originalIncorrect = document.getElementById('id_incorrecteditable');\n            if (modalCorrect && originalCorrect) {\n              originalCorrect.innerHTML = modalCorrect.innerHTML;\n            }\n            if (modalIncorrect && originalIncorrect) {\n              originalIncorrect.innerHTML = modalIncorrect.innerHTML;\n            }\n            let JSONstr = item.updateJson(e);\n            // Enable all atto elements\n            let attoElements = document.querySelectorAll('[class^=\"atto_\"]');\n            attoElements.forEach(element => {\n              element.removeAttribute('disabled');\n            });\n            document.querySelector(\"[name='itemsettings']\").value = JSONstr;\n            /* Set editable to true as it is checked at the start of click */\n            let questionTextEditable = document.getElementById('id_questiontexteditable');\n            if (questionTextEditable) {\n              questionTextEditable.setAttribute('contenteditable', 'true');\n            }\n            document.getElementById('id_itemsettings_button').click();\n            modal.destroy();\n          });\n          // Handle the cancel event\n          modal.getRoot().on(ModalEvents.cancel, function() {\n            // Enable all atto elements\n            let attoElements = document.querySelectorAll('[class^=\"atto_\"]');\n            attoElements.forEach(element => {\n              element.removeAttribute('disabled');\n            });\n            modal.destroy();\n          });\n          return modal;\n        }).catch(function(error) {\n          // Handle any errors in creating the modal\n          console.error('Error creating modal:', error);\n        });\n      };\n      /**\n       * Convert an object to an array\n       * @param {object} obj\n       * @return {array}\n       */\n      const toArray = obj => {\n        let arr = [];\n        for (let i = 0, iLen = obj.length; i < iLen; i++) {\n          arr.push(obj[i]);\n        }\n        return arr;\n      };\n      // Wrap the words of an element and child elements in a span.\n      // Recurs over child elements, add an ID and class to the wrapping span.\n      // Does not affect elements with no content, or those to be excluded.\n      const wrapContent = (function() {\n        return function(el) {\n          let count = 0;\n          let gaps = [];\n          // If element provided, start there, otherwise use the body.\n          el = el && el.parentNode ? el : document.body;\n          // Get all child nodes as a static array.\n          let node,\n            nodes = toArray(el.childNodes);\n          if (el.id === 'id_questiontextfeedback' && count > 0) {\n            count = 0;\n          }\n          let frag, text;\n          let delimitchars = document.getElementById('id_delimitchars').value;\n          let l = delimitchars.substring(0, 1);\n          let r = delimitchars.substring(1, 2);\n          let regex = new RegExp('(\\\\' + l + '.*?\\\\' + r + ')', 'g');\n          let sp,\n            span = document.createElement('span');\n          // Tag names of elements to skip, there are more to add.\n          const skip = {\n            script: '',\n            button: '',\n            input: '',\n            select: '',\n            textarea: '',\n            option: '',\n          };\n          // For each child node...\n          for (let i = 0, iLen = nodes.length; i < iLen; i++) {\n            node = nodes[i];\n            // If it's an element, call wrapContent.\n            if (node.nodeType === 1 && !(node.tagName.toLowerCase() in skip)) {\n              wrapContent(node);\n              // If it's a text node, wrap words.\n            } else if (node.nodeType === 3) {\n              let textsplit = new RegExp('(\\\\' + l + '.*?\\\\' + r + ')', 'g');\n              text = node.data.split(textsplit);\n              if (text) {\n                // Create a fragment, handy suckers these.\n                frag = document.createDocumentFragment();\n                for (let j = 0, jLen = text.length; j < jLen; j++) {\n                  // If not whitespace, wrap it and append to the fragment.\n                  doGap(text, span, j);\n                }\n              }\n              // Replace the original node with the fragment.\n              node.parentNode.replaceChild(frag, node);\n            }\n          }\n          /**\n           * Process each gap\n           *\n           * @param {*} text\n           * @param {*} span\n           * @param {*} j\n           */\n          function doGap(text, span, j) {\n            gaps = [];\n            if (regex.test(text[j])) {\n              sp = span.cloneNode(false);\n              count++;\n              sp.className = 'item';\n              let item = new Item(text[j], document.getElementById('id_delimitchars').value);\n              if (item.gaptext > '') {\n                let instance = 0;\n                for (let k = 0; k < gaps.length; ++k) {\n                  if (gaps[k] === item.text) {\n                    instance++;\n                  }\n                }\n                item.id = 'id' + count + '_' + instance;\n                sp.id = item.id;\n                let is = item.getItemSettings(item);\n                if (item.striptags(is.correctfeedback) > '') {\n                  sp.className = 'hascorrect';\n                }\n                if (item.striptags(is.incorrectfeedback) > '') {\n                  sp.className = sp.className + ' ' + 'hasnocorrect';\n                }\n                gaps.push(item.gaptext);\n              }\n              sp.appendChild(document.createTextNode(text[j]));\n              frag.appendChild(sp);\n              // Otherwise, just append it to the fragment.\n            } else {\n              frag.appendChild(document.createTextNode(text[j]));\n            }\n          }\n        };\n      })();\n      /**\n       *\n       * @param {array} source\n       * @return {array} product\n       */\n      const copyStyles = source => {\n        // The map to return with requested styles and values as KVP.\n        let product = {};\n        // The style object from the DOM element we need to iterate through.\n        let style;\n        // Recycle the name of the style attribute.\n        let name;\n        // Prevent from empty selector.\n        if (source.length) {\n          // Otherwise, we need to get everything.\n          let dom = source.get(0);\n          if (window.getComputedStyle) {\n            // Convenience methods to turn css case ('background-image') to camel ('backgroundImage').\n            const pattern = /-([a-z])/g;\n            const uc = (a, b) => b.toUpperCase();\n            const camelize = string => string.replace(pattern, uc);\n            // Make sure we're getting a good reference.\n            if ((style = window.getComputedStyle(dom, null))) {\n              let camel, value;\n              for (let i = 0, l = style.length; i < l; i++) {\n                name = style[i];\n                camel = camelize(name);\n                value = style.getPropertyValue(name);\n                product[camel] = value;\n              }\n            } else if ((style = dom.currentStyle)) {\n              for (name in style) {\n                product[name] = style[name];\n              }\n            } else if ((style = dom.style)) {\n              product = getStyle(style, product, name);\n            }\n            return product;\n          }\n        }\n        return false;\n      };\n      /**\n       * TODO check if this function is needed\n       * @param {string} style\n       * @param {object} product\n       * @param {string} name\n       * @returns {string}\n       */\n      function getStyle(style, product, name) {\n        for (name in style) {\n          if (typeof style[name] != 'function') {\n            product[name] = style[name];\n          }\n        }\n        return product;\n      }\n    },\n  };\n});"],"names":["define","Item","ModalFactory","ModalEvents","init","setElementProps","id","properties","element","document","getElementById","Object","keys","forEach","prop","addEventListener","selected","this","value","disabled","checked","activeEditor","querySelector","querySelectorAll","length","errorElement","style","display","color","innerHTML","M","util","get_string","button","setAttribute","questionTextEditable","isContentEditable","settingformheight","window","getComputedStyle","height","settingformwidth","width","canvas","styles","copyStyles","assign","closest","appendChild","position","background","wrapContent","backgroundColor","removeAttribute","handleAttoItemSettings","tinyMCE","console","error","possibleIds","editor","get","editors","ed","container","getContainer","editorContainer","mode","set","settingsPopup","editorContent","getContent","padding","border","minHeight","parentNode","insertBefore","nextSibling","handleTinyItemSettings","e","target","match","delimitchars","item","itemsettings","getItemSettings","correctfeedback","incorrectfeedback","label","textContent","title","tempDiv","createElement","stripdelim","openItemSettingsDialog","popupContent","create","type","types","SAVE_CANCEL","body","large","then","modal","show","modalRoot","getRoot","modalDialog","maxWidth","on","shown","modalCorrect","modalIncorrect","originalCorrect","originalIncorrect","save","JSONstr","updateJson","click","destroy","cancel","catch","el","node","frag","text","count","gaps","nodes","obj","arr","i","iLen","push","toArray","childNodes","sp","l","substring","r","regex","RegExp","span","skip","script","input","select","textarea","option","nodeType","tagName","toLowerCase","textsplit","data","split","createDocumentFragment","j","jLen","doGap","replaceChild","test","cloneNode","className","gaptext","instance","k","is","striptags","createTextNode","source","name","product","dom","pattern","uc","a","b","toUpperCase","camelize","string","replace","camel","getPropertyValue","currentStyle","getStyle"],"mappings":"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"}