{"version":3,"file":"questionedit.min.js","sources":["../src/questionedit.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * JavaScript code for the gapfill question type.\n *\n * @copyright  2017 Marcus Green\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n/* The data is stored in a hidden field */\ndefine(['qtype_gapfill/Item'], function(Item) {\n  return {\n    init: function() {\n      /**\n       * Helper function to set element properties by ID\n       * @param {string} id - Element ID\n       * @param {object} properties - Object containing property-value pairs to set\n       */\n      function setElementProps(id, properties) {\n        let element = document.getElementById(id);\n        if (element) {\n          Object.keys(properties).forEach(function(prop) {\n            element[prop] = properties[prop];\n          });\n        }\n      }\n\n      /**\n       * Check which editor is active on the page\n       * @return {string|null} Returns 'tinymce', 'atto', or null if neither is active\n       */\n      function getActiveEditor() {\n        // Check if TinyMCE is active\n        if (document.querySelector('.tox-tinymce')) {\n          return 'tinymce';\n        }\n\n        // Check if Atto is active\n        let attoIsLive = document.querySelectorAll('.editor_atto').length;\n\n        if (attoIsLive > 0) {\n          return 'atto';\n        }\n\n        return null;\n      }\n\n      /**\n       * Handle Atto editor specific item settings functionality\n       */\n      function handleAttoItemSettings() {\n        let questionTextEditable = document.getElementById('id_questiontexteditable');\n        if (questionTextEditable.isContentEditable) {\n          questionTextEditable.setAttribute('contenteditable', 'false');\n          // Disable all buttons in fitem_id_questiontext\n          let buttons = document.getElementById('fitem_id_questiontext').querySelectorAll('button');\n          buttons.forEach(function(button) {\n            button.setAttribute('disabled', 'true');\n          });\n          let settingformheight = window.getComputedStyle(questionTextEditable).height;\n          let settingformwidth = window.getComputedStyle(questionTextEditable).width;\n          questionTextEditable.style.display = 'none';\n          /* Copy the styles from attos editable area so the canvas looks the same (except gray) */\n          let canvas = document.getElementById('id_itemsettings_canvas');\n          let styles = copyStyles(questionTextEditable);\n          Object.assign(canvas.style, styles);\n          let ed = questionTextEditable.closest('.editor_atto_content_wrap');\n          ed.appendChild(canvas);\n          canvas.style.position = 'relative';\n          canvas.style.display = 'block';\n          canvas.style.background = 'lightgrey';\n          /* Copy the real html to the feedback editing html */\n          canvas.innerHTML = questionTextEditable.innerHTML;\n          canvas.style.height = settingformheight;\n          canvas.style.width = settingformwidth;\n          canvas.style.height = '100%';\n          canvas.style.width = '100%';\n          document.getElementById('id_itemsettings_button').innerHTML =\n            M.util.get_string('editquestiontext', 'qtype_gapfill');\n          /* Setting the height by hand gets around a quirk of MSIE */\n          canvas.style.height = window.getComputedStyle(questionTextEditable).height;\n          /* Disable the buttons on questiontext but not on the feedback form */\n          /* wrapContent should be the last on this block as it sometimes falls over with an error */\n          wrapContent(canvas);\n        } else {\n          questionTextEditable.style.display = 'block';\n          questionTextEditable.style.backgroundColor = 'white';\n          questionTextEditable.setAttribute('contenteditable', 'true');\n          document.getElementById('id_itemsettings_canvas').style.display = 'none';\n          // Enable all buttons in fitem_id_questiontext\n          let buttons = document.getElementById('fitem_id_questiontext').querySelectorAll('button');\n          buttons.forEach(function(button) {\n            button.removeAttribute('disabled');\n          });\n          document.getElementById('id_settings_popup').style.display = 'none';\n          document.getElementById('id_itemsettings_button').innerHTML =\n            M.util.get_string('additemsettings', 'qtype_gapfill');\n          // Enable all elements with class starting with atto_\n          let attoElements = document.querySelectorAll('[class^=\"atto_\"]');\n          attoElements.forEach(function(element) {\n            element.removeAttribute('disabled');\n          });\n        }\n      }\n\n      document.getElementById('id_answerdisplay').addEventListener('change', function() {\n        let selected = this.value;\n\n        if (selected == 'gapfill') {\n          setElementProps('id_fixedgapsize', { disabled: false });\n          setElementProps('id_optionsaftertext', { disabled: true, checked: false });\n          setElementProps('id_singleuse', { disabled: true, checked: false });\n          setElementProps('id_disableregex', { disabled: false });\n        }\n\n        if (selected == 'dragdrop') {\n          setElementProps('id_optionsaftertext', { disabled: false });\n          setElementProps('id_singleuse', { disabled: false });\n          setElementProps('id_fixedgapsize', { disabled: false });\n          setElementProps('id_disableregex', { disabled: false });\n        }\n\n        if (selected == 'dropdown') {\n          setElementProps('id_fixedgapsize', { disabled: true, checked: false });\n          setElementProps('id_optionsaftertext', { disabled: true, checked: false });\n          setElementProps('id_singleuse', { disabled: true, checked: false });\n          setElementProps('id_disableregex', { disabled: true, checked: false });\n        }\n      });\n\n      /* A click on the itemsettings button */\n      document.getElementById('id_itemsettings_button').addEventListener('click', function() {\n        let activeEditor = getActiveEditor();\n        /* Show error if no supported editor is active. It might be because the page has not finished loading\n         * or because plain text elements are being used or (perhaps less likely as time goes on)\n         * the HTMLarea editor is being used. It might be possible to work with those other editors\n         * but limiting to supported editors keeps things straightforward and maintainable.\n         */\n        if (!activeEditor) {\n          let errorElement = document.getElementById('id_error_itemsettings_button');\n          errorElement.style.display = 'inline';\n          errorElement.style.color = 'red';\n          errorElement.innerHTML = M.util.get_string(\n            'itemsettingserror',\n            'qtype_gapfill'\n          );\n          return;\n        }\n        // Disable editor-specific buttons based on active editor\n        if (activeEditor === 'atto') {\n          let htmlButtons = document.querySelectorAll('#questiontext .atto_html_button');\n          htmlButtons.forEach(function(button) {\n            button.setAttribute('disabled', 'true');\n          });\n\n          // Invoke the Atto-specific function\n          handleAttoItemSettings();\n        } else if (activeEditor === 'tinymce') {\n            alert('tinymce not implemented yet');\n            return;\n          // Add TinyMCE-specific button disabling if needed\n        }\n      });\n\n      /* A click on the text */\n      document.getElementById('id_itemsettings_canvas').addEventListener('click', function(e) {\n        /*\n         * Questiontext needs to be edditable and the target must start\n         * with id followed by one or more digits and an underscore\n         * */\n        if (\n          !document.getElementById('id_questiontexteditable').isContentEditable &&\n          e.target.id.match(/^id[0-9]+_/)\n        ) {\n          let delimitchars = document.getElementById('id_delimitchars').value;\n          let item = new Item(e.target.innerHTML, delimitchars);\n          // Var item = new Item(e.target.innerHTML, delimitchars);\n          let itemsettings = item.getItemSettings(e.target);\n          if (itemsettings === null || itemsettings.length === 0) {\n            document.getElementById('id_correcteditable').innerHTML = '';\n            document.getElementById('id_incorrecteditable').innerHTML = '';\n          } else {\n            document.getElementById('id_correcteditable').innerHTML = itemsettings.correctfeedback;\n            document.getElementById('id_incorrecteditable').innerHTML = itemsettings.incorrectfeedback;\n          }\n          // Set label texts\n          let correctLabels = document.querySelectorAll(\"label[for*='id_correct']\");\n          correctLabels.forEach(function(label) {\n            label.textContent = M.util.get_string('correct', 'qtype_gapfill');\n          });\n          let incorrectLabels = document.querySelectorAll(\"label[for*='id_incorrect']\");\n          incorrectLabels.forEach(function(label) {\n            label.textContent = M.util.get_string('incorrect', 'qtype_gapfill');\n          });\n          // Disable specific atto buttons\n          let imageButtons = document.querySelectorAll('#id_itemsettings_popup .atto_image_button');\n          imageButtons.forEach(function(button) {\n            button.setAttribute('disabled', 'true');\n          });\n          let mediaButtons = document.querySelectorAll('#id_itemsettings_popup .atto_media_button');\n          mediaButtons.forEach(function(button) {\n            button.setAttribute('disabled', 'true');\n          });\n          let manageFilesButtons = document.querySelectorAll('#id_itemsettings_popup .atto_managefiles_button');\n          manageFilesButtons.forEach(function(button) {\n            button.setAttribute('disabled', 'true');\n          });\n          let title = M.util.get_string('additemsettings', 'qtype_gapfill');\n          /* The html jquery call will turn any encoded entities such as &gt; to html, i.e. > */\n          let tempDiv = document.createElement('div');\n          tempDiv.innerHTML = item.stripdelim();\n          title += ': ' + tempDiv.textContent;\n          // Use jQuery UI for dialog since it's already required\n          require(['jquery', 'jqueryui'], function($) {\n            $('#id_itemsettings_popup').dialog({\n              position: {\n                my: 'right',\n                at: 'right',\n                of: '#id_itemsettings_canvas',\n              },\n              height: 500,\n              width: '70%',\n              modal: false,\n              title: title,\n              buttons: [\n                {\n                  text: 'OK',\n                  id: 'SaveItemFeedback',\n                  click: function() {\n                    let JSONstr = item.updateJson(e);\n                    // Enable all atto elements\n                    let attoElements = document.querySelectorAll('[class^=\"atto_\"]');\n                    attoElements.forEach(function(element) {\n                      element.removeAttribute('disabled');\n                    });\n                    document.querySelector(\"[name='itemsettings']\").value = JSONstr;\n                    $('.ui-dialog-content').dialog('close');\n                    /* Set editable to true as it is checked at the start of click */\n                    document.getElementById('id_questiontexteditable').setAttribute(\n                      'contenteditable',\n                      'true'\n                    );\n                    document.getElementById('id_itemsettings_button').click();\n                  },\n                },\n              ],\n            });\n          });\n        }\n      });\n\n      /**\n       * Convert an object to an array\n       * @param {object} obj\n       * @return {array}\n       */\n      function toArray(obj) {\n        let arr = [];\n        for (let i = 0, iLen = obj.length; i < iLen; i++) {\n          arr.push(obj[i]);\n        }\n        return arr;\n      }\n\n      // Wrap the words of an element and child elements in a span.\n      // Recurs over child elements, add an ID and class to the wrapping span.\n      // Does not affect elements with no content, or those to be excluded.\n      const wrapContent = (function() {\n        return function(el) {\n          let count = 0;\n          let gaps = [];\n          // If element provided, start there, otherwise use the body.\n          el = el && el.parentNode ? el : document.body;\n          // Get all child nodes as a static array.\n          let node,\n            nodes = toArray(el.childNodes);\n          if (el.id === 'id_questiontextfeedback' && count > 0) {\n            count = 0;\n          }\n          let frag, text;\n          let delimitchars = document.getElementById('id_delimitchars').value;\n          let l = delimitchars.substring(0, 1);\n          let r = delimitchars.substring(1, 2);\n          let regex = new RegExp('(\\\\' + l + '.*?\\\\' + r + ')', 'g');\n          let sp,\n            span = document.createElement('span');\n          // Tag names of elements to skip, there are more to add.\n          const skip = {\n            script: '',\n            button: '',\n            input: '',\n            select: '',\n            textarea: '',\n            option: '',\n          };\n          // For each child node...\n          for (let i = 0, iLen = nodes.length; i < iLen; i++) {\n            node = nodes[i];\n            // If it's an element, call wrapContent.\n            if (node.nodeType === 1 && !(node.tagName.toLowerCase() in skip)) {\n              wrapContent(node);\n              // If it's a text node, wrap words.\n            } else if (node.nodeType === 3) {\n              let textsplit = new RegExp('(\\\\' + l + '.*?\\\\' + r + ')', 'g');\n              text = node.data.split(textsplit);\n              if (text) {\n                // Create a fragment, handy suckers these.\n                frag = document.createDocumentFragment();\n                for (let j = 0, jLen = text.length; j < jLen; j++) {\n                  // If not whitespace, wrap it and append to the fragment.\n                  doGap(text, span, j);\n                }\n              }\n              // Replace the original node with the fragment.\n              node.parentNode.replaceChild(frag, node);\n            }\n          }\n          /**\n           * Process each gap\n           *\n           * @param {*} text\n           * @param {*} span\n           * @param {*} j\n           */\n          function doGap(text, span, j) {\n            gaps = [];\n            if (regex.test(text[j])) {\n              sp = span.cloneNode(false);\n              count++;\n              sp.className = 'item';\n              let item = new Item(text[j], document.getElementById('id_delimitchars').value);\n              if (item.gaptext > '') {\n                let instance = 0;\n                for (let k = 0; k < gaps.length; ++k) {\n                  if (gaps[k] === item.text) {\n                    instance++;\n                  }\n                }\n                item.id = 'id' + count + '_' + instance;\n                sp.id = item.id;\n                let is = item.getItemSettings(item);\n                if (item.striptags(is.correctfeedback) > '') {\n                  sp.className = 'hascorrect';\n                }\n                if (item.striptags(is.incorrectfeedback) > '') {\n                  sp.className = sp.className + ' ' + 'hasnocorrect';\n                }\n                gaps.push(item.gaptext);\n              }\n              sp.appendChild(document.createTextNode(text[j]));\n              frag.appendChild(sp);\n              // Otherwise, just append it to the fragment.\n            } else {\n              frag.appendChild(document.createTextNode(text[j]));\n            }\n          }\n        };\n      })();\n\n      /**\n       *\n       * @param {array} source\n       * @return {array} product\n       */\n      function copyStyles(source) {\n        // The map to return with requested styles and values as KVP.\n        let product = {};\n        // The style object from the DOM element we need to iterate through.\n        let style;\n        // Recycle the name of the style attribute.\n        let name;\n        // Prevent from empty selector.\n        if (source.length) {\n          // Otherwise, we need to get everything.\n          let dom = source.get(0);\n          if (window.getComputedStyle) {\n            // Convenience methods to turn css case ('background-image') to camel ('backgroundImage').\n            const pattern = /-([a-z])/g;\n            const uc = function(a, b) {\n              return b.toUpperCase();\n            };\n            const camelize = function(string) {\n              return string.replace(pattern, uc);\n            };\n            // Make sure we're getting a good reference.\n            if ((style = window.getComputedStyle(dom, null))) {\n              let camel, value;\n              for (let i = 0, l = style.length; i < l; i++) {\n                name = style[i];\n                camel = camelize(name);\n                value = style.getPropertyValue(name);\n                product[camel] = value;\n              }\n            } else if ((style = dom.currentStyle)) {\n              for (name in style) {\n                product[name] = style[name];\n              }\n            } else if ((style = dom.style)) {\n              product = getStyle(style, product, name);\n            }\n            return product;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * TODO check if this function is needed\n       * @param {string} style\n       * @param {object} product\n       * @param {string} name\n       * @returns {string}\n       */\n      function getStyle(style, product, name) {\n        for (name in style) {\n          if (typeof style[name] != 'function') {\n            product[name] = style[name];\n          }\n        }\n        return product;\n      }\n    },\n  };\n});"],"names":["define","Item","init","setElementProps","id","properties","element","document","getElementById","Object","keys","forEach","prop","handleAttoItemSettings","questionTextEditable","isContentEditable","setAttribute","querySelectorAll","button","settingformheight","window","getComputedStyle","height","settingformwidth","width","style","display","canvas","styles","source","name","product","length","dom","get","pattern","uc","a","b","toUpperCase","camelize","string","replace","camel","value","i","l","getPropertyValue","currentStyle","getStyle","copyStyles","assign","closest","appendChild","position","background","innerHTML","M","util","get_string","wrapContent","backgroundColor","removeAttribute","addEventListener","selected","this","disabled","checked","activeEditor","querySelector","errorElement","color","alert","e","target","match","delimitchars","item","itemsettings","getItemSettings","correctfeedback","incorrectfeedback","label","textContent","title","tempDiv","createElement","stripdelim","require","$","dialog","my","at","of","modal","buttons","text","click","JSONstr","updateJson","el","node","frag","count","gaps","nodes","obj","arr","iLen","push","toArray","parentNode","body","childNodes","sp","substring","r","regex","RegExp","span","skip","script","input","select","textarea","option","nodeType","tagName","toLowerCase","textsplit","data","split","createDocumentFragment","j","jLen","doGap","replaceChild","test","cloneNode","className","gaptext","instance","k","is","striptags","createTextNode"],"mappings":"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"}